- only logical accept and reject or physical accept and reject?
	physical (!!!) accept and reject states in they should be in the list
	because:
		- it is a state like every other state and so the user can
		  expect that this state has a real ID like all other states
		  and so it is reachable like every other state in the state_list
		  ACCEPT = 0; REJECT = 1
		  => maybe state-member of edge-object should be a pointer and not an ID!
			option 1: special pointers and real IDS then we could
				  place the states also in the state list because
				  the next (first real state) has to start with 2
				  and this is confusing for the user!
				  because accepting and rejecting state have no IDs
				  but why??? they are states like every other state
			option 2: special pointers and no real IDs, then we
				  abuse the state object and cannot deal with
				  IDs instead we have to use obscure things like
				  ACCEPT and REJECT...these things would be ints
				  and THEN you can create a fucking ID for them
			option 3: no special pointers and no real IDs in statelist
				  see above in option 2 (id problem)
			option 4: no state-object for reject and accept means a special entry
				  in the edge-object ONLY for the accepting and rejecting state!
				  special entry in edge object but an extra entry
				  just for 2 fucking states...mhm but many edges to them...
				  but then ID-Problem...id_dest in edge would be abused (not set!!!)
				  because there is no actual state and state pointer (target pointer)
				  cannot solve this because there is no state object for accept and reject
				  solution = set target state pointer in edge to NULL...and state_type is ACCEPT|REJECT
				  and state pointer may not be NULL for NORMAL
			REAL STATES because if we use logical states we have
				to create a fucking function for everything like
				tm_add_edge_default_accept tm_add_edge_default_reject
				tm_add_edge_accept, tm_add_edge_reject


no tape_action instead only tape_actions with arrays!!!

TODO: error handling in error.c and erring.c

normal print is export to dot? great...

brillant idea:

	k: number of tapes

	read anything; write something: NULL, V, {L, S, R}^k
	read anything; write nothing: NULL, NULL, {L, S, R}^k
	read something; write something: V, V, {L, S, R}^k
	read something; write nothing: V, NULL, {L, S, R}^k

	(r, w, {L, NULL, R})
	(r, w, {L, NULL, R})
	(r, w, {L, NULL, R})
	(r, w, {L, NULL, R})
	(r, w, {L, NULL, R})

	if direction array == NULL then no movement on all tapes!
	

	only L and R and if it is NULL then S

	tape_actions: 3 arrays (with k length) of pointers with same length

	tape_action: 3 pointers to single elements

	tape_actions: array of tape_action with k length


- forking of turing machine? - COW tape (only cell copy)
- better distinction between data and state of tm?
- subroutine / concat als uebergang
- no alphabet, _just_ uintptr_t and check() and is_blank()
- add WRITE_NOTHING member to edge_default
- tape_new_empty() should be possible!!!
- several tapes - not working - read as vector and not as distinct tokens!
- beautify includes

grammar interpreter/parser on the base of this tm-project
manowar generator on the base of this tm-project
general parser for cool stuff like own xml

/**
 *	1) All macros,constants and enums in caps: MAX_BUFFER_SIZE, TRACKING_ID_PREFIX.
 *	2) Struct names and typedef's in snake_case
 *	3) Functions that operate on structs: structname_method(structname *this, ...)
 *	5) Global variables: just don't use global variables. They are evil.
 *	6) Functions that are there, but shouldn't be called directly,
 *	or have obscure uses, or whatever: one or more underscores
 *	at the beginning: __structname_function_name()
 *	7) List-Classes: List-Class of example is: example_list
 *	7.1) element name is "node":
 *		example_list_add_node(example_list *this, ...)
 *		exampel_list_del_node(example_list *this, ...)
 *	8) Array-Classes: Array-Class of example is: examples with members "data" and "length"
 *	9) EVERY Class has a structname_free method!!!

never only one underscore

user pointer in edge, state, or tm?

advantages of list_classes:
	- list container type
		=> size member
	- strict difference between entry and list
	- ID HANDLING IN LIST IS INDEPENDET FROM STATE CREATION
 *
 *	NFA: TuringMachine with one (read-only) tape. Only valid direction is
 *	LEFT and computation stops when end of tape is reached or first blank
 *	is read
 *
 *	=> Conclusion: maybe add for every state edge with (q_x, BLANK) => REJECT
 *
 *	BETTER: Every state of a (deterministic) Turing Machine has to have X
 *		outgoing edges. X is the cardinality of the tape-alphabet.
 *		So add negative edges: when there is no outgoing edge for x
 *		then go to the REJECT state.
 *
 *	Event for every transition? Would be cool for endless machines
 *	or to call a function...callback
 *
 *	Add INPUT ALPHABET AND TAPE ALPHABET and make it local to Turing Machine
 *
 * TASKS:
 *	- TODO grammar support!
 *			- TODO unite, concat, intersect
 *
 *
 *
 * NFA:
 * 1: Add state: just add node to node_list (regular list)
 * 2: Add edge: set token (and tape_output if transductor...this will be written to tape!)
 * 		set targets with id of targets
 *		set edge *next...(regular list)
 *
 * PDA:
 * 1: Add state: just add node to node_list (regular list)
 * 2: Add edge: set token (and tape_output of second tape if transductor...this will be written to tape!)
 * 		set targets with id of targets
 * 		set edge *next...(regular list)
 * 		set tape_input if there is a stack to read from...
 *		set tape_output if there is a stack to write to...
 *
 * Turing Machine:
 * 1: Add state: just add node to node_list (regular list)
 * 2: Add edge: set token
 * 		set targets with id of targets
 * 		set edge *next...(regular list)
 * 		"select" tape_s_
 * 		set tape_shift_dir to set shift direction on tape...
 * 		
 * Possible combinations: DFA, DFA_Transductor, NFA, NFA_Transductor, PDA, PDA_Transductor, Turing Machine (multiple tapes)
 *
 * number and kind of tapes...complicated
 * nfa and dfa may only contain ONE tape (read-only)
 * nfa_t and dfa_t may contain TWO tapes (read-only and write-only)
 * pda may contain TWO tapes (read-only and read-write)
 * pda_t may contain THREE tapes (read-only, read-write, write-only)
 * turing machine may contain X tapes (read-write shift)
 */

/*struct grammar {
	struct __grammar *grammar;
};

struct __grammar {
	struct rules *left_side;
	struct rules *right_side;
};

struct rules {
	struct __rules *rules;
	unsigned int num; 
};

struct __rules {
	union __rule *rules;
	unsigned int num;
};

union __rule {
	char terminal;
	char non_terminal;
};

enum TYPES {
	IS_DET = 1,
	IS_TRANS = 2,
	IS_NFA = 4,
	IS_PDA = 8,
	IS_TM = 16
};



/*
 * add_edge(tm *machine, state *src, state *dest, ...);
 *
 *
 * NFA:  	add_edge(tm *machine, state *src, state *dest, 'x', NULL)
 * NFA_T:	add_edge(tm *machine, state *src, state *dest, 'x', 'y', NULL)
 * PDA:  	add_edge(tm *machine, state *src, state *dest, 'x', 'y', 'z', NULL)
 * PDA_T:	add_edge(tm *machine, state *src, state *dest, 'x', 'y', 'z', 'a', NULL)
 * TURING(1):  	add_edge(tm *machine, state *src, state *dest, 'x', 'y', NULL)
 * TURING(3):  	add_edge(tm *machine, state *src, state *dest, 'x', 'y', 'a', 'b', 'c', 'd', NULL)
*/
