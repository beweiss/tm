- only logical accept and reject or physical accept and reject?
- forking of turing machine? - COW tape (only cell copy)
- better distinction between data and state of tm?
- subroutine / concat als uebergang
- no alphabet, _just_ uintptr_t and check() and is_blank()
- add WRITE_NOTHING member to edge_default
- tape_new_empty() should be possible!!!
- several tapes - not working - read as vector and not as distinct tokens!
- assert!!!!
- beautify includes

grammar interpreter/parser on the base of this tm-project
manowar generator on the base of this tm-project
general parser for cool stuff like own xml

/**
 *	1) All macros,constants and enums in caps: MAX_BUFFER_SIZE, TRACKING_ID_PREFIX.
 *	2) Struct names and typedef's in snake_case
 *	3) Functions that operate on structs: structname_method(structname *this, ...)
 *	5) Global variables: just don't use global variables. They are evil.
 *	6) Functions that are there, but shouldn't be called directly,
 *	or have obscure uses, or whatever: one or more underscores
 *	at the beginning: __structname_function_name()
 *	7) List-Classes: List-Class of example is: example_list
 *	7.1) element name is "node":
 *		example_list_add_node(example_list *this, ...)
 *		exampel_list_del_node(example_list *this, ...)
 *	8) Array-Classes: Array-Class of example is: examples with members "data" and "length"
 *	9) EVERY Class has a structname_free method!!!

"In point six I prefer to use static and skip the module prefix, 
so if gtk_widget_show() was a function with file scope it would 
become simply widget_show() with static storage class added. "

never only one underscore

user pointer in edge, state, or tm?

advantages of list_classes:
	- list container type
		=> size member
	- strict difference between entry and list
	- ID HANDLING IN LIST IS INDEPENDET FROM STATE CREATION
 *
 *	NFA: TuringMachine with one (read-only) tape. Only valid direction is
 *	LEFT and computation stops when end of tape is reached or first blank
 *	is read
 *
 *	=> Conclusion: maybe add for every state edge with (q_x, BLANK) => REJECT
 *
 *	BETTER: Every state of a (deterministic) Turing Machine has to have X
 *		outgoing edges. X is the cardinality of the tape-alphabet.
 *		So add negative edges: when there is no outgoing edge for x
 *		then go to the REJECT state.
 *
 *	Event for every transition? Would be cool for endless machines
 *	or to call a function...callback
 *
 *	Add INPUT ALPHABET AND TAPE ALPHABET and make it local to Turing Machine
 *
 * TASKS:
 *	- TODO grammar support!
 *			- TODO unite, concat, intersect
 *
 *
 *
 * NFA:
 * 1: Add state: just add node to node_list (regular list)
 * 2: Add edge: set token (and tape_output if transductor...this will be written to tape!)
 * 		set targets with id of targets
 *		set edge *next...(regular list)
 *
 * PDA:
 * 1: Add state: just add node to node_list (regular list)
 * 2: Add edge: set token (and tape_output of second tape if transductor...this will be written to tape!)
 * 		set targets with id of targets
 * 		set edge *next...(regular list)
 * 		set tape_input if there is a stack to read from...
 *		set tape_output if there is a stack to write to...
 *
 * Turing Machine:
 * 1: Add state: just add node to node_list (regular list)
 * 2: Add edge: set token
 * 		set targets with id of targets
 * 		set edge *next...(regular list)
 * 		"select" tape_s_
 * 		set tape_shift_dir to set shift direction on tape...
 * 		
 * Possible combinations: DFA, DFA_Transductor, NFA, NFA_Transductor, PDA, PDA_Transductor, Turing Machine (multiple tapes)
 *
 * number and kind of tapes...complicated
 * nfa and dfa may only contain ONE tape (read-only)
 * nfa_t and dfa_t may contain TWO tapes (read-only and write-only)
 * pda may contain TWO tapes (read-only and read-write)
 * pda_t may contain THREE tapes (read-only, read-write, write-only)
 * turing machine may contain X tapes (read-write shift)
 */

/*struct grammar {
	struct __grammar *grammar;
};

struct __grammar {
	struct rules *left_side;
	struct rules *right_side;
};

struct rules {
	struct __rules *rules;
	unsigned int num; 
};

struct __rules {
	union __rule *rules;
	unsigned int num;
};

union __rule {
	char terminal;
	char non_terminal;
};

enum TYPES {
	IS_DET = 1,
	IS_TRANS = 2,
	IS_NFA = 4,
	IS_PDA = 8,
	IS_TM = 16
};



/*
 * add_edge(tm *machine, state *src, state *dest, ...);
 *
 *
 * NFA:  	add_edge(tm *machine, state *src, state *dest, 'x', NULL)
 * NFA_T:	add_edge(tm *machine, state *src, state *dest, 'x', 'y', NULL)
 * PDA:  	add_edge(tm *machine, state *src, state *dest, 'x', 'y', 'z', NULL)
 * PDA_T:	add_edge(tm *machine, state *src, state *dest, 'x', 'y', 'z', 'a', NULL)
 * TURING(1):  	add_edge(tm *machine, state *src, state *dest, 'x', 'y', NULL)
 * TURING(3):  	add_edge(tm *machine, state *src, state *dest, 'x', 'y', 'a', 'b', 'c', 'd', NULL)
*/
